<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proyecto Final Programación</title>
    <link rel="stylesheet" href="index.css">
</head>
<body>
    <div class="head">
        <div class="img-head">
            <img id="banner" src="./img/cod.png" alt="">
        </div>
        <div class="info">
            <h1>Proyecto Final: Programación.</h1>
            <p><b>Realizado por:</b> Benavides Hernandez Isaac Alain</p>
            <p><b>Sección:</b> D24</p>
            <p><b>NRC:</b> 42556</p>
            <p><b>Horario:</b> Martes y Jueves de 11 AM a 1 PM.</p>
        </div>
    </div>
    <div class="flex-main">
        <main>
            <div class="contenido">
                <div class="unidad" id="programacion-estructurada">
                    <h2>Módulo 1: Programación estructurada.</h2>
                        <h3>1.1. Conceptos basicos de programación estructurada.</h3>
                            <h4 class="sub">1.1.1. Definición y características de programación estructurada.</h4>
                            <p>
                                La programación estructurada es una teoria de programación que busca mejorar la claridad, calidad y el tiempo de desarrollo de un programa. <br><br>
                                A los finales de los años 70 surgió esta forma de programar, propuesta por Bohm-Jacopini quien decia que era posible escribir todos los programas y aplicaciones posibles utilizando solo 3 estructuras de control fundamentales. Dejando fuera a la instrucción de transferencia incondicional (GOTO). <br><br>
                                Esta tecnica de programación conduce a mejorar la claridad, calidad y tiempo de desarrollo de un programa. 
                            </p>

                            <h4 class="sub">1.1.2. Elementos básicos de programación estructurada.</h4>
                            <p>
                                Como ya se menciono anteriormente, en la programación estructurada se utilizan solo 3 estructuras de control para evitar los problemas que generaba la instrucción de transferencia incondicional, estas tres estructuras son las siguientes:
                                <ul>
                                    <li><b>Estructuras secuenciales:</b> Esta estructura se utiliza para que las instrucciones de un programa se ejecuten una después de la otra.</li>
                                    <li><b>Estructuras condicionales:</b> Esta estructura plantea la selección de instrucciones entre varias opciones dependiendo del valor de una condición, cierto o falso o tambien dependiendo del valor de una variable.</li>
                                    <li><b>Estructuras repetitivas:</b> Esta estructura ejecuta un conjunto de instrucciones repetidamente hasta que una condición sea cumplida, o mientras una condición sea verdadrea, dependiendo de la estructura de repetición.</li>
                                </ul>
                                <br>
                                <p>
                                    Estas estructuras no necesitan estar aisladas unas de otras, pueden estar juntas o anidadas, cualquiera de ellas.
                                </p>
                            </p>
                            <img src="./img/secuencial.png" alt="">
                        <br><br><br>
                        <h3>1.2. Algoritmo.</h3>
                            <h4 class="sub">1.2.1. Definición de Algoritmo.</h4>
                            <p>
                                Un algoritmo es una serie de instrucciones secuenciales que permiten ejecutar acciones o realizar alguna determinada acción. Sin los algoritmos nadie sabria que hacer, y las acciones que se buscan hacer no se podrian realizar.
                            </p>
                            <p>
                                Especificamente en el desarrollo de software existen dos tipos de algoritmos:
                                <ul>
                                    <li><b>Cuantitativos: </b>son aquellos cuya resolución depende de un cálculo matemático.</li>
                                    <li><b>Cualitativo: </b>la resolución de estos no depende de cálculos numéricos, sino de secuencias lógicas.</li>
                                </ul>
                            </p>
                            <h4 class="sub">1.2.2. Tecnicas para la formulación de algoritmos.</h4>
                            <p>En el proceso de desarrollo de software se utilizan principalmente las siguientes dos tecnicas para clarificar el proceso que se debe de llevar:</p>
                            
                            <h4>1.2.2.1. Diagramas de flujo</h4>
                            <p>Un diagrama de flujo es la representación gráfica de un algoritmo. También se puede decir que es la representación detallada en forma gráfica de como deben realizarse los pasos en la computadora para producir resultados. Describen un proceso, sistema o algoritmo informático. Se usan ampliamente en varios campos para documentar, estudiar, planificar, mejorar y comunicar procesos que suelen ser complejos.</p>
                            <p>A continuación se muestra una tabla de las estructuras utilizadas en los diagramas de flujo.</p>
                            <div class="tabla">
                                <div class="row">
                                    <div class="cell-img"><img src="./img/1/1.2.2.1.gif" alt=""></div>
                                    <div class="cell"><p>Indica Inicio o Fin.</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell-img"><img src="./img/1/1.2.2.2.gif" alt=""></div>
                                    <div class="cell"><p>Indica Impresión de datos en consola.</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell-img"><img src="./img/1/1.2.2.3.gif" alt=""></div>
                                    <div class="cell"><p>Indica la entrada o salida de datos.</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell-img"><img src="./img/1/1.2.2.4.gif" alt=""></div>
                                    <div class="cell"><p>Indica un proceso interno del programa previamente definido, una asignación de un valor en memoria y/o una operación aritmética.</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell-img"><img src="./img/1/1.2.2.7.gif" alt=""></div>
                                    <div class="cell"><p>Indica una estructura selectiva. En el centro se escribe la condición y en las lineas que parten de el la opción que representan.</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell-img"><img src="./img/1/1.2.2.5.gif" alt=""></div>
                                    <div class="cell"><p>Indica un conector dentro de la misma página. Esto representa la continuidad del diagrama dentro de la misma página.</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell-img"><img src="./img/1/1.2.2.6.gif" alt=""></div>
                                    <div class="cell"><p>Indica un conector fuera de la misma página. Esto representa la continuidad del diagrama en una distinta página.</p></div>
                                </div>
                            </div>
                            
                            <h4>1.2.2.2. Pseudocódigo</h4>
                            <p>Es una manera de representar el algoritmo en lenguaje español, esto crea una representación más entendible del código del lenguaje de programación para las personas que no estan familiarizadas con la programación.</p>
                            <p>A pesar de que no es dificil traducir el código a pseudocódigo una vez que se conoce el lenguaje C, dejare una lista de palabras utilizadas frecuentemente.</p>
                            <div class="tabla" id="pseudo">
                                <div class="row">
                                    <div class="cell"><p><b>Código en C:</b></p></div>
                                    <div class="cell"><p><b>Pseudocódigo:</b></p></div>
                                </div>
                                <div class="row">
                                    <div class="cell"><p>int</p></div>
                                    <div class="cell"><p>Entero</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell"><p>float</p></div>
                                    <div class="cell"><p>Real</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell"><p>char</p></div>
                                    <div class="cell"><p>Carácter</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell"><p>void</p></div>
                                    <div class="cell"><p>Ninguno</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell"><p>return</p></div>
                                    <div class="cell"><p>Regresa</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell"><p>if</p></div>
                                    <div class="cell"><p>Si</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell"><p>else</p></div>
                                    <div class="cell"><p>Sino</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell"><p>for()</p></div>
                                    <div class="cell"><p>Desde()</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell"><p>while()</p></div>
                                    <div class="cell"><p>Mientras()</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell"><p>do..while()</p></div>
                                    <div class="cell"><p>Hacer...Mientras()</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell"><p>printf()></p></div>
                                    <div class="cell"><p>Imprimir()</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell"><p>scanf()</p></div>
                                    <div class="cell"><p>Leer()</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell"><p>break</p></div>
                                    <div class="cell"><p>Salir</p></div>
                                </div>
                            </div>
                                <p class="ejemplo">Ejemplo (Práctica 2): </p> <br>
                                <pre>Principal <br>Inicio <br>    Entero n1, n2, res<br>    Imprimir("Dime dos enteros")<br>    Leer(n1, n2)<br>    res ← n1 + n2<br>    Imprimir("El resultado es: ", res)<br>Fin
                                </pre>

                        <h3>1.3. Estructuras de control.</h3>
                            <h4 class="sub">1.3.1. Definición.</h4>
                                <p>Son los métodos que existen dentro de un programa para dirigir la forma en la que se ejecutan las isntrucciones. Estas modifican el flujo de ejecución, manipulandolo para conveniencia del programa.</p>
                            <h4 class="sub">1.3.2. Secuencial.</h4>
                            <p>La estructura secuencial es aquella estructura que ejecutará las instrucciones que contiene dentro de ella en orden descendente. Tienen la siguiente estructura: <br> <br> <pre>Inicio <br>    Instrucción 1 <br>    Instrucción 2 <br>    ... <br>    Instrucción n <br>Fin</pre></p>
                            <p><br>El ejemplo más sencillo y utilizado de este tipo de estructuras son las funciones, las cuales seran cubiertas más a fondo algunos temas adelante.</p>
                                <p class="ejemplo">Ejemplo (Práctica 1).</p>
                                <p class="ejemplo">Pseudocódigo:</p>
                                <pre>Principal<br>Inicio<br>    Entero a ← 0, b ← 5, c ← 12<br>    a ← b + c / 2 * 10<br>    Imprimir(“a =”, a)<br>    b ← a * a modulo 3<br>    Imprimir(“b =”, b)<br>    c ← 20 modulo 3 / 2 * 5<br>    Imprimir(“c =”, c)<br>    b ← b + c * a + (20 - a)<br>    Imprimir(“b =”, b)<br>Fin</pre>
                                <p class="ejemplo">Diagrama de flujo:</p>
                                <img src="./img/1/1.3.2.jpg" alt="" style="height: 60rem; width: auto;">
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/2024905584ae4d4efdabe752306eb73e.js"></script>
                                <p class="ejemplo">Captura en ejecución: </p>
                                <img src="./img/1/1.3.2_2.jpg" alt="">

                            <h4 class="sub">1.3.3. Selectiva.</h4>
                            <p>Es una estructura que ejecuta las instrucciones que contiene dependiendo de si la condición con la que fue declarada es verdadera o es falsa. Este tipo de estructura de control se divide en 3 tipos de estructuras secuenciales, la selectiva simple, la selectiva doble y la selectiva multiple.</p>

                            <h4>1.3.3.1. Si y si-sino.</h4>
                            <p>Esta se refiere a dos tipos de estructuras selectivas, la simple y la doble. La estructura selectiva simple es aquella que solo ejecutara las instrucciones que contiene si la condición evaluada es verdadera, si la condición es falsa, esta estructura no ejecutara absolutamente nada.</p>
                            <p>Mientras que la selectiva doble es la estructura selectiva que tiene dos opciones para ejecutar instrucciones, cuando la condición que evalua es verdadera ejecuta un conjunto de instrucciones y si es falsa otro conjunto diferente de instrucciones.</p>
                            <p>Existe una derivación de estos dos tipos anteriores, en la cual se utilizan multiples estructuras Si y Si-Sino, a esta se le conoce como estructura selectiva doble anidada y esta tiene más de dos posibilidades para ejecutar instrucciones, si una condición es falsa, se puede evaluar otra condición y si esa es falsa se puede evaluar otra y asi sucesivamente dependiendo de lo que necesitamos solucionar con nuestro programa.</p>
                                
                                <p class="ejemplo">Ejemplo selectiva simple (Práctica 8).</p>
                                <p class="ejemplo">Pseudocódigo:</p>
                                <pre>Librerias<br>Principal<br>Inicio<br>    Entero ed<br>    Imprimir("Dame tu edad:")<br>    Leer(ed)<br>    Si (ed < 18)<br>    Inicio<br>        Imprimir("Eres menor de edad")<br>        Imprimir("No puedes votar")<br>    Fin<br>    Imprimir("Que tengas un buen día")<br>Fin</pre>
                                <p class="ejemplo">Diagrama de flujo:</p>
                                <img src="./img/1/1.3.3.1.1.jpg" alt="" style="height: 60rem; width: auto;">
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/e4836bd1774f04cb098fe2d97d93fb62.js"></script>
                                <p class="ejemplo">Captura en ejecución: </p>
                                <img src="./img/1/1.3.3.1.1_2.jpg" alt="">

                                <br>

                                <p class="ejemplo">Ejemplo selectiva doble (Práctica 10).</p>
                                <p class="ejemplo">Pseudocódigo:</p>
                                <pre>Librerias<br>Inicio<br>    Entero num<br>    Imprimir("Por favor ingrese un numero entero:")<br>    Leer(num)<br>    Si (num > 0)<br>        Imprimir("Es positivo")<br>    Sino<br>        Imprimir("Es negativo")<br>Fin</pre>
                                <p class="ejemplo">Diagrama de flujo:</p>
                                <img src="./img/1/1.3.3.1.2.jpg" alt="" style="height: 60rem; width: auto;">
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/5291d157bbfcab7b85d33162b2608494.js"></script>
                                <p class="ejemplo">Captura en ejecución: </p>
                                <img src="./img/1/1.3.3.1.2_2.jpg" alt="">

                                <br>

                                <p class="ejemplo">Ejemplo selectiva doble anidada (Práctica 12).</p>
                                <p class="ejemplo">Pseudocódigo:</p>
                                <pre>Librerias<br>Inicio<br>    Entero n1, n2, n3<br>    Imprimir("Ingresa 3 números enteros:")<br>    Leer(n1, n2, n3)<br>    Si ((n1 > n2) Y (n1 > n3))<br>        Imprimir("El numero 'n1' es el mayor.")<br>    Sino si ((n2 > n1) Y (n2 > n3))<br>        Imprimir("El numero 'n2' es el mayor.")<br>    Sino Si ((n3 > n1) Y (n3 > n2))<br>        Imprimir("El numero 'n3' es el mayor.")<br>    Sino<br>        Imprimir("Hay dos o más números iguales.")<br>Fin</pre>
                                <p class="ejemplo">Diagrama de flujo:</p>
                                <img src="./img/1/1.3.3.1.3.jpg" alt="" style="height: 60rem; width: auto;">
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/ec32df4545707c82ab4a08a899c1a5b3.js"></script>
                                <p class="ejemplo">Captura en ejecución: </p>
                                <img src="./img/1/1.3.3.1.3_2.jpg" alt="">

                            <h4>1.3.3.2. Según sea.</h4>
                            <p>Esta es un tipo de estructura selectiva que permite definir múltiples casos que puede llegar a cumplir una variable, y que acción o acciones tomar en cualquiera de estas situaciones, incluso es posible determinar qué acción llevar a cabo en caso de no cumplir ninguna de las condiciones dadas.</p>
                                <p class="ejemplo">Ejemplo (Práctica 16).</p>
                                <p class="ejemplo">Pseudocódigo:</p>
                                <pre>Librerias<br>Principal<br>Inicio<br>    Entero opc, l1, l2, area, bMenor, bMayor, h, radio<br>    Imprimir("Elige una opcion: 1. Cuadro 2. Rectangulo 3. Circulo 4. Trapecio")<br>    Leer(opc)<br>    Segun sea (opc)<br>    Inicio<br>        Caso 1:<br>            Inicio<br>                Imprimir("Dime la longitud del lado del cuadro:")<br>                Leer(l1)<br>                area <- l1 * l1<br>                Imprimir("El area del cuadro es", area)<br>                Interrumpir<br>            Fin<br>        Caso 2:<br>            Inicio<br>                Imprimir("Dime la longitud del primer lado del rectangulo:")<br>                Leer(l1)<br>                Imprimir("Dime la longitud del segundo lado del rectangulo:")<br>                Leer(l2)<br>                area <- l1 * l2<br>                Imprimir("El area del rectangulo es", area)<br>                Interrumpir<br>            Fin<br>        Caso 3:<br>            Inicio<br>                Imprimir("Dime la longitud del radio del circulo:")<br>                Leer(radio)<br>                area <- (3.1416 * (radio * radio))<br>                Imprimir("El area del circulo es", area)<br>                Interrumpir<br>            Fin<br>        Caso 4:<br>            Inicio<br>                Imprimir("Por favor ingresa la longitud de la Base Mayor del trapecio:")<br>                Leer(bMayor)<br>                Imprimir("Por favor ingresa la longitud de la Base Menor del trapecio:")<br>                Leer(bMenor)<br>                Imprimir("Por favor ingresa la Altura del trapecio:")<br>                Leer(h)<br>                area <- ((bMayor + bMenor) * h) / 2<br>                Imprimir("El area del trapecio es", area)<br>                Interrumpir<br>            Fin<br>        Otro:<br>            Imprimir("No existe esa opción")<br>    Fin<br>    Regresa 0<br>Fin</pre>
                                <p class="ejemplo">Diagrama de flujo:</p>
                                <img src="./img/1/1.3.3.2.jpg" alt="">
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/bf8cbd728663b3a318f5e8f47b2d0911.js"></script>
                                <p class="ejemplo">Captura en ejecución: </p>
                                <img src="./img/1/1.3.3.2.1.jpg" alt="">

                            <h4 class="sub">1.3.4. Estructuras de control repetitivas.</h4>
                            <p>Las estructuras de control repetitivas son las estructuras que ejecutaran un bloque de instrucciones mientras una condición evaluada sea verdadera, esta estructura ejecutara las instrucciones que contiene hasta que la condición sea falsa, o en su defecto, se repetirá el número de veces que el programador indique.</p>
                            <h4>1.3.4.1. Contadores, acumuladores y banderas.</h4>
                            <p><b>Contador: </b>Un contador es una variable a la cual su valor se incrementa o decrementa en una cantidad constante cada vez que se produce un determinado suceso o acción. Estos se utilizan con la finalidad de contar las veces que sucede una acción o para controlar el proceso de un bucle. En algunas ocasiones, dependiendo la lógica que necesitemos que el bucle siga, se ocupara inicializar un valor en el contador, para que arranque desde ese número y no desde el 0, como el lenguaje C suele hacer.</p>
                            <br>
                            <p><b>Acumulador: </b>Un acumulador es una variable que suma sobre si misma un conjunto de valores para de esta manera tener la suma de todos ellos en una sola variable. La diferencia entre un contador y un acumulador es que el acumulador normalmente solo aumenta de 1 en 1, el acumulador no aumenta en una cantidad constante.</p>
                            <br>
                            <p><b>Bandera: </b>Una bandera es una variable, normalmente con un valor booleano, que nos indica si ha ocurrido un suceso. Esta se utiliza como una señal para una función, un bucle o una estructura selectiva. Frecuentemente se utiliza una analogía de un interruptor para ejemplificar este concepto, si la bandera es falsa es como si el interruptor estuviera apagado, y si es verdadera es como si el interruptor estuviera encendido.</p>

                            <h4>1.3.4.2. Mientras.</h4>
                            <p>La estructura de control repetitiva While o "Mientras" es la estructura que analiza una condición al principio, si esta es verdadera entra al ciclo while, al igual que una sentencia If, y cuando termina de ejecutar las instrucciones que contiene, vuelve a analizar la condición del principio, si es verdadera vuelve a ejecutar las instrucciones que contiene, si es falsa, pasa a la siguiente instrucción que no este contenida en el.</p>
                                <p class="ejemplo">Ejemplo (Práctica 22).</p>
                                <p class="ejemplo">Pseudocódigo:</p>
                                <pre>Librerias<br>Principal<br>Inicio<br>    Entero con <- 105;<br>    Mientras (con >= 1)<br>        Inicio<br>            Imprimir(con)<br>            con = con -2<br>        Fin<br>    Regresa 0<br>Fin</pre>
                                <p class="ejemplo">Diagrama de flujo:</p>
                                <img src="./img/1/1.3.4.2.jpg" alt="" style="width: 40%; height: auto;">
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/ad97c88c319614be51b15b4f5dfc4211.js"></script>
                                <p class="ejemplo">Captura en ejecución: </p>
                                <img src="./img/1/1.3.4.2.1.jpg" alt="" style="width: 40%; height: auto;">

                            <h4>1.3.4.3. Hacer-Mientras.</h4>
                            <p>La estructura de control repetitiva Do...While o "Hacer-Mientras" es la estructura que analiza una condición al final de su estructura, si esta es verdadera volverá a ejecutar las instrucciones que contiene, para finalizar de ejecutar las instrucciones que contiene, la condición que se evalua al final debe ser falsa, esta estructura se ejecutará al menos 1 vez.</p>
                                <p class="ejemplo">Ejemplo (Práctica 26).</p>
                                <p class="ejemplo">Pseudocódigo:</p>
                                <pre>Librerías<br>Principal<br>Inicio<br>    Entero i ← 1, res<br>    Hacer<br>        Inicio<br>            res ← i * 7<br>            Imprimir("7 x 'i' = 'res'")<br>            inc i<br>        Fin<br>    Mientras (i <= 10)<br>Fin</pre>
                                <p class="ejemplo">Diagrama de flujo:</p>
                                <img src="./img/1/1.3.4.3.1.jpg" alt="" style="width: 20%; height: auto;">
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/07377162a9f382e49f368629928ceee4.js"></script>
                                <p class="ejemplo">Captura en ejecución: </p>
                                <img src="./img/1/1.3.4.3.2.jpg" alt="">
                                
                                <h4>1.3.4.4. Desde.</h4>
                                <p>La estructura de control repetitiva For o "Desde" es la estructura que repetición que tiene que declarar al principio el valor inicial de la variable de control, la condición que evaluara el ciclo y la manera en la que se va a modificar la variable de control en cada ciclo. Esta estructura normalmente define el número de veces que va a repetir las instrucciones que contiene desde el momento en el que se declara.</p>
                                <p class="ejemplo">Ejemplo (Práctica 29).</p>
                                <p class="ejemplo">Pseudocódigo:</p>
                                <pre>Librerías<br>Principal<br>Inicio<br>    Entero tabla, i, lim, res<br>    Imprimir("Por favor ingresa la tabla de multiplicar que quiere visualizar: ")<br>    Leer(tabla)<br>    Imprimir("Por favor ingrese el límite de la tabla de multiplicar: ")<br>    Leer(lim)<br>    Desde (i <- 1; i <= lim; inc i)<br>    Inicio<br>        res <- tabla * i<br>        Imprimir("'tabla' x 'i' = 'res'")<br>    Fin<br>Fin</pre>
                                <p class="ejemplo">Diagrama de flujo:</p>
                                <img src="./img/1/1.3.4.4.1.jpg" alt="" style="width: 30%;">
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/b7ed4d606156a75cc51ade045394df6f.js"></script>
                                <p class="ejemplo">Captura en ejecución: </p>
                                <img src="./img/1/1.3.4.4.2.jpg" alt="">

                        <h3>1.4. Estructuras anidadas.</h3>
                            <h4 class="sub">1.4.1. Definición.</h4>
                            <p>Las estructuras de control, tanto selectivas como repetitivas, no solo pueden convivir solas o entre ellas, si no que se pueden hacer el uso de tantas de estas estructuras como sea necesario para resolver un problema, incluso dentro de otra estructura de control, a la manera en la que se ponen estructuras dentro de otras estructuras se le llama anidación, y puede existir en cualquier estructura de control.</p>

                            <h4 class="sub">1.4.2. Implementación.</h4>
                            <p>El caso de uso más común de las estructuras anidadas son las estructuras de repetición anidadas para el manejo de arreglos bidimensionales, los cuales veremos más adelante, aqui se presenta un ejemplo de anidación de estructuras de repetición.</p>
                                <p class="ejemplo">Ejemplo (Práctica 31).</p>
                                <p class="ejemplo">Pseudocódigo:</p>
                                <pre>Librerías<br> Principal<br> Inicio<br>     Entero i, j<br>     Desde (i <- 1; i <= 10; inc i)<br>         Inicio<br>             Imprimir("Tabla de multiplicar del ", i)<br>             Desde (j <- 1; j <= 10; inc j)<br>                 Inicio<br>                     Imprimir(i, "x", j, "=", (i*j))<br>                 Fin<br>         Fin<br>     Regresa(0)<br> Fin</pre>
                                <p class="ejemplo">Diagrama de flujo:</p>
                                <img src="./img/1/1.4.2.1.jpg" alt="" style="width: 50%;">
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/fe926cbe72ef65c1f9d9b57bf47f16ef.js"></script>
                                <p class="ejemplo">Captura en ejecución: </p>
                                <img src="./img/1/1.4.2.2.jpg" alt="">

                </div>
                <div class="unidad" id="arreglos">
                    <h2>Módulo 2: Arreglos.</h2>
                        <h3>2.1. Definición.</h3>
                        <p>Un arreglo es una variable que provee la opción de disponer de varios datos o espacio para datos a los cuales se puede acceder y se manejan con un mismo identificador, este tipo de variable a pesar de que guarda varios datos, permite la utilización individual de sus elementos, guarda todos sus elementos en espacios continuos en memoria.</p>
                        <h3>2.2. Tipos de arreglos.</h3>
                            <h4 class="sub">2.2.1. Unidimensionales.</h4>
                            <p>Los arreglos unidimensionales son variables estructuradas formadas con un número "n" de variables simples del mismo tipo que son denominadas elementos del arreglo. El número de componentes "n" es la dimensión del arreglo. En programación a este tipo de arreglos tambien se le conocen como vectores.</p>
                            <br><p><b>Estructura de un vector de 5 elementos: </b></p>
                            <div class="tabla" id="unidimensional">
                                <div class="row">
                                    <div class="cell" style="background-color: rgba(0, 131, 92, 1);"><p style="color: #e9e9e9;">Índice</p></div>
                                    <div class="cell"><p>0</p></div>
                                    <div class="cell"><p>1</p></div>
                                    <div class="cell"><p>2</p></div>
                                    <div class="cell"><p>3</p></div>
                                    <div class="cell"><p>4</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell" style="background-color: rgba(0, 131, 92, 1);"><p style="color: #e9e9e9;">Valor</p></div>
                                    <div class="cell"><p>7</p></div>
                                    <div class="cell"><p>88</p></div>
                                    <div class="cell"><p>14</p></div>
                                    <div class="cell"><p>0</p></div>
                                    <div class="cell"><p>45</p></div>
                                </div>
                            </div>

                            <p class="ejemplo">Ejemplo (Práctica 37).</p>
                            <p class="ejemplo">Pseudocódigo:</p>
                                <pre>Librerías<br>Principal<br>Inicio<br>    Entero array[15], mayor ← 0, i<br>    Desde (i ← 0; i < 15; inc i)<br>        Inicio<br>            Imprimir("Por favor ingresa el elemento", i)<br>            Leer(array[i])<br>        Fin<br>    Desde (i ← 0; i < 15; inc i)<br>        Inicio<br>            Si (array[i] > mayor)<br>                mayor ← array[i]<br>        Fin<br>    Imprimir("El elemento mayor es: ", mayor)<br>Fin</pre>
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/d65f57af46a232ca733af54c176b3a3b.js"></script>
                                <p class="ejemplo">Captura en ejecución: </p>
                                <img src="./img/2/2.2.1.jpg" alt="">
                            
                            <p>Existe un tipo de arreglo unidimensional que se utiliza para poder suplir lo que en otros lenguajes de programación se conoce como el tio de dato String, las cadenas o cadenas de carácter. <br>La única diferencia entre los arreglos y las cadenas de carácter es que las cadenas se pueden manipular de manera individual y de manera conjunta, puedes imprimir un solo carácter de la cadena o la cadena completa.</p>
                            <br><p><b>Estructura de una cadena de 5 elementos: </b></p>
                            <div class="tabla" id="unidimensional">
                                <div class="row">
                                    <div class="cell" style="background-color: rgba(0, 131, 92, 1);"><p style="color: #e9e9e9;">Índice</p></div>
                                    <div class="cell"><p>0</p></div>
                                    <div class="cell"><p>1</p></div>
                                    <div class="cell"><p>2</p></div>
                                    <div class="cell"><p>3</p></div>
                                    <div class="cell"><p>4</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell" style="background-color: rgba(0, 131, 92, 1);"><p style="color: #e9e9e9;">Valor</p></div>
                                    <div class="cell"><p>H</p></div>
                                    <div class="cell"><p>O</p></div>
                                    <div class="cell"><p>L</p></div>
                                    <div class="cell"><p>A</p></div>
                                    <div class="cell"><p>\0</p></div>
                                </div>
                            </div>

                            <p class="ejemplo">Ejemplo (Práctica 46).</p>
                            <p class="ejemplo">Pseudocódigo:</p>
                            <pre>Librerias<br>Principal<br>Inicio<br>    Caracter cadena[26]<br>    Entero total<br>    Imprimir("Introduce una oración (máx. 25 carácteres): ")<br>    Leercad(cadena)<br>    total <- Longitud_de_cadena(cadena)<br>    Imprimir("La longitud de la cadena es: ", total)<br>Fin</pre>
                            <p class="ejemplo">Código en C:</p>
                            <script src="https://gist.github.com/isaac-bh/b7ab6a6c96d4645b8e973db47b49cea1.js"></script>
                            <p class="ejemplo">Captura en ejecución: </p>
                            <img src="./img/2/2.2.1.1.png" alt="">

                            <h4 class="sub">2.2.2. Bidimensionales.</h4>
                            <p>Los arreglos bidimensionales son un tipo de variable estructurada formada de un número "n" de celdas por un número "m" de filas. Tambien se podria decir que son varios arreglos unidimensionales unidos. Este tipo de arreglos utiliza dos índices para ubicar a los datos, el número de fila y el número de celda. Tambien se les denominan matrices.</p>
                            <br><p><b>Estructura de una matriz de 5x5: </b></p>
                            <div class="tabla" id="unidimensional">
                                <div class="row">
                                    <div class="cell" style="background-color: rgba(0, 131, 92, 1);"><p style="color: #e9e9e9;">Índice</p></div>
                                    <div class="cell" style="background-color: rgba(0, 131, 92, 1);"><p style="color: #e9e9e9;">0</p></div>
                                    <div class="cell" style="background-color: rgba(0, 131, 92, 1);"><p style="color: #e9e9e9;">1</p></div>
                                    <div class="cell" style="background-color: rgba(0, 131, 92, 1);"><p style="color: #e9e9e9;">2</p></div>
                                    <div class="cell" style="background-color: rgba(0, 131, 92, 1);"><p style="color: #e9e9e9;">3</p></div>
                                    <div class="cell" style="background-color: rgba(0, 131, 92, 1);"><p style="color: #e9e9e9;">4</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell" style="background-color: rgba(0, 131, 92, 1);"><p style="color: #e9e9e9;">0</p></div>
                                    <div class="cell"><p>7</p></div>
                                    <div class="cell"><p>88</p></div>
                                    <div class="cell"><p>14</p></div>
                                    <div class="cell"><p>0</p></div>
                                    <div class="cell"><p>45</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell" style="background-color: rgba(0, 131, 92, 1);"><p style="color: #e9e9e9;">1</p></div>
                                    <div class="cell"><p>25</p></div>
                                    <div class="cell"><p>50</p></div>
                                    <div class="cell"><p>75</p></div>
                                    <div class="cell"><p>100</p></div>
                                    <div class="cell"><p>0</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell" style="background-color: rgba(0, 131, 92, 1);"><p style="color: #e9e9e9;">2</p></div>
                                    <div class="cell"><p>13</p></div>
                                    <div class="cell"><p>39</p></div>
                                    <div class="cell"><p>57</p></div>
                                    <div class="cell"><p>82</p></div>
                                    <div class="cell"><p>91</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell" style="background-color: rgba(0, 131, 92, 1);"><p style="color: #e9e9e9;">3</p></div>
                                    <div class="cell"><p>12</p></div>
                                    <div class="cell"><p>3</p></div>
                                    <div class="cell"><p>7</p></div>
                                    <div class="cell"><p>82</p></div>
                                    <div class="cell"><p>92</p></div>
                                </div>
                                <div class="row">
                                    <div class="cell" style="background-color: rgba(0, 131, 92, 1);"><p style="color: #e9e9e9;">4</p></div>
                                    <div class="cell"><p>48</p></div>
                                    <div class="cell"><p>12</p></div>
                                    <div class="cell"><p>677</p></div>
                                    <div class="cell"><p>99</p></div>
                                    <div class="cell"><p>101</p></div>
                                </div>
                            </div>
                                <p class="ejemplo">Ejemplo (Práctica 44).</p>
                                <p class="ejemplo">Pseudocódigo:</p>
                                <pre>Librerías<br>Principal<br>Inicio<br>    Entero i, j, k<br>    Real a[3][3], b[3][3], c[3][3], suma<br>    Desde (i ← 0; i < 3; inc i)<br>    Inicio<br>        Desde (j ← 0; j < 3; inc j)<br>        Inicio<br>            Imprimir("Por favor ingresa el elemento ", i + 1, j + 1, "de la matriz A:")<br>            Leer(a[i][j])<br>            Imprimir("Por favor ingresa el elemento ", i + 1, j + 1, "de la matriz B:")<br>            Leer(b[i][j])<br>        Fin<br>    Fin<br>    <br>    Desde (i ← 0; i < 3; inc i)<br>    Inicio<br>        Desde (j ← 0; j < 3; inc j)<br>        Inicio<br>            c[i][j] ← 0<br>            Desde (k ← 0; k < 3; inc k)<br>                c[i][j] ← (c[i][j] + (a[i][k] * b[k][j])) <br>        Fin<br>    Fin<br><br>    Desde (i ← 0; i < 3; inc i)<br>    Inicio<br>        Desde (j ← 0; j < 3; inc j)<br>            Imprimir(c[i][j])<br>        Imprimir(\n)<br>    Fin<br>Fin</pre>
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/5413a08f1dd14b075e4f6a9719272a95.js"></script>
                                <p class="ejemplo">Captura en ejecución: </p>
                                <img src="./img/2/2.2.2.jpg" alt="">

                </div>
                <div class="unidad" id="funciones">
                    <h2>Módulo 3: Manejo de funciones.</h2>
                        <h3>3.1. Definición.</h3>
                        <p>En el lenguaje de programación C, una función es el equivalente a lo que es una subrutina en otros lenguajes de programación. Es una forma conveniente de encapsular o aislar algunos cálculos o algún procedimiento, los cuales se pueden emplear despúes. Las funciones se diseñan para cumplir con una tarea especifica y para tener un código más modulado y organizado.</p>
                        <p>Las funciones en el lenguaje C pueden aparecer en cualquier orden y en uno o varios archivos fuente, pero una función no puede separarse, ni en el mismo archivo ni en diferentes.</p>
                        <p>Al igual que las variables, las funciones también necesitan ser declaradas. Lo que se les conoce como prototipo de una función. Esto solo se necesita hacer si las funciones fueron declaradas después de la función principal.</p>
                        <br>
                        <p><b>Parámetros:</b></p>
                        <p>Los parámetros son las variables nombradas en la lista entre paréntesis de la definición de una función. Los parámetros deben ser declarados con su tipo de dato y su respectivo identificador. Es posible no especificar exactamente la cantidad de parámetros que recibirá la función, para esto es necesario poner una coma seguida de tres puntos (,...), esto le indica al compiladorr que puede que pasen más argumentos a la función, pero no se le proporciona más información acerca de ellos.</p>
                        <br>
                        <p><b>Variables y sus alcances:</b></p>
                        <p>Las variables que son declaradas dentro de una función comienzan a existir desde el momento en el que se invoca a la función y son borradas de memoria cuando la función termina, estas son llamadas variables locales. <br>Como alternativa de las variables locales, se pueden declarar variables externas o globales, las cuales son accesibles desde cualquier parte del programa.</p>
                        <p>Cuando una variable es transferida de una función a otra, normalmente se transfiere "por valor", es decir, que la función que es invocada recibe los valores de sus argumentos en variables temporales y no en las originales. Una función que es invocada en el lenguaje C no puede modificar el valor de una variable que esta en la función que la invocó, unicamente puede modificar su copia privada y temporal.</p>


                        <h3>3.2. Funciones sin paso de párametros.</h3>
                        <p>Las funciones sin paso de párametros son aquellas que no reciben ningún valor de entrada cuando es invocada, únicamente ejecuta el código que contiene dentro de la función y puede regresar un valor a la función que la invocó.</p>
                            <p class="ejemplo">Ejemplo (Práctica 52).</p>
                                <p class="ejemplo">Pseudocódigo:</p>
                                <pre>Librerías<br>Raiz()<br>Inicio<br>    Real num, res<br>    Imprimir("Ingresa el número que se le desea aplicar la raíz cuadrada: ")<br>    Leer(num)<br>    res <- Raizcuad(num)<br>    Regresa res<br>Fin<br><br>Potencia()<br>Inicio<br>    Real num, res, potencia<br>    Imprimir("Ingresa el número que se le desea aplicar la potencia: ")<br>    Leer(num)<br>    Imprimir("Ingresa la potencia deseada: ")<br>    Leer(potencia)<br>    res <- num ^ potencia<br>    Regresar res<br>Fin<br><br>Coseno()<br>Inicio<br>    Real num, res<br>    Imprimir("Ingresa el número que se desea calcular el coseno: ")<br>    Leer(num)<br>    res <- cos(num)<br>    Regresa res<br>Fin<br><br>logaritmoNatural()<br>Inicio<br>    Real num, res<br>    Imprimir("Ingresa el número que se desea calcular el logaritmo natural: ")<br>    Leer(num)<br>    res <- log(num)<br>    Regresa res<br>Fin<br><br>Principal()<br>Inicio<br>    Entero menu <- 1, opc<br>    Hacer<br>        Inicio<br>            Imprimir("Bienvenido!, Que operación quieres realizar?")<br>            Imprimir("1. Raíz Cuadrada 2. Potencia de un numero 3. Coseno de un numero 4. Logaritmo natural<br>            de un número. 5. Salir del programa");<br>            Imprimir("Ingresa el numero de la opción: ");<br>            Leer(opc)<br>            Según sea ()<br>            Inicio<br>                Caso 1:<br>                    Imprimir("La raíz es: ", Raiz())<br>                    Interrumpir<br>                Caso 2:<br>                    Imprimir("La potencia es: ", Potencia())<br>                    Interrumpir<br>                Caso 3:<br>                    Imprimir("El coseno es: ", Coseno())<br>                    Interrumpir<br>                Caso 4:<br>                    Imprimir("El logaritmo natural es: ", logaritmoNatural())<br>                    Interrumpir<br>                Caso 5:<br>                    Imprimir("Adiós")<br>                    Interrumpir<br>                Otro:<br>                    Imprimir("Opción inexistente")<br>                    Interrumpir<br>            Fin<br>        Fin<br>    Mientras(menu = 1)<br>    Regresa 0<br>Fin</pre>
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/5613c4eedad921b6d3dbedb1f18e310b.js"></script>
                                <p class="ejemplo">Captura en ejecución: </p>
                                <img src="./img/3/3.2.jpg" alt="">

                        <h3>3.3. Funciones con paso de párametros por valor.</h3>
                        <p>Las funciones con paso de párametros son aquellas que reciben uno o más valores en el momento en el que son invocadas, esto con el proposito de realizar un proceso con esos datos o un proceso condicionado al valor de esos datos.</p>
                        <p>Existen dos tipos de paso de párametros, el paso de párametros por valor y el paso de párametros por referencia.</p>
                        <br>
                        <p><b>Por valor: </b>En este tipo de paso de párametros los valores de las variables son copiados en un grupo de variables locales dentro de la función, por lo que si se modifica el valor de estas, no tendra impacto en las variables originales. Los datos primitivos como Int, Float, Double y Char utilizan este método de paso de párametros.</p>
                        <br>
                        <p><b>Por referencia: </b>En este tipo de paso de párametros las variables no son pasadas del todo, si no que se pasa la dirección en memoria hacia la función y ya en esta se utiliza la dirección que le fue proporcionada para guardar datos, es todo lo contrario al anterior método, ya que esta si modifica el valor de las variables originales. Los datos de tipo arreglo utilizan este método de paso de párametros.</p>
                            <h4 class="sub">3.3.1. Funciones con parámetros usando datos primitivos.</h4>
                                <p class="ejemplo">Ejemplo (Práctica 54).</p>
                                <p class="ejemplo">Pseudocódigo:</p>
                                <pre>Librerías<br>Entero factorial(Entero fact)<br>Inicio<br>    Entero contador, total <- 1<br>    contador <- factorial<br>    Hacer<br>        Inicio<br>            total <- total * contador<br>            dec contador<br>        Fin<br>    Mientras (contador >= 1)<br>    Regresa total<br>Fin<br><br>Entero Principal()<br>Inicio<br>    Entero fact<br>    Imprimir("Ingrese el factorial a calcular: ")<br>    Leer(fact)<br>    Imprimir("El factorial del número que elegiste es: ", factorial(fact))<br>    Regresa 0<br>Fin</pre>
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/81f0612f4df62b1aa9e31703dbf8936d.js"></script>
                                <p class="ejemplo">Captura en ejecución: </p>
                                <img src="./img/3/3.3.1.jpg" alt="">
                                
                                
                            <h4 class="sub">3.3.2. Funciones con parámetros usando arreglos.</h4>
                                <p class="ejemplo">Ejemplo (Práctica 60).</p>
                                <p class="ejemplo">Pseudocódigo:</p>
                                <pre>Librerías<br>Constante TAM 100<br><br>Entero ordenar (entero n, entero x[])<br><br>Principal<br>Inicio<br>    Entero i, n, x[TAM]<br>    Imprimir("¿Cuántos números serán introducidos?")<br>    Leer(n)<br>    Desde(i <- 0; i < n; inc i)<br>    Inicio<br>        Imprimir("i = ", i + 1, "x = ")<br>        Leer(x[i])<br>    Fin<br>    ordenar(n, x)<br>    Imprimir("Lista de números ordenada")<br>    Desde (i <- 0; i < n; inc i)<br>        Imprimir("i = ", i + 1, "x = ", x[i])<br>    Regresa(0)<br>Fin<br><br>Entero ordenar(Entero n, Entero x[])<br>Inicio<br>    Entero i, elem, temp<br>    Desde(elem <- 0; elem < n - 1; inc elem)<br>    Inicio<br>        Desde(i <- elem + 1; i < n; inc i)<br>        Inicio<br>            Si (x[i] < x[elem])<br>            Inicio<br>                temp <- x[elem]<br>                x[elem] <- x[i]<br>                x[i] <- temp<br>            Fin<br>        Fin<br>    Fin<br>    Regresa(0)<br>Fin</pre>
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/4577131f2f98d7d9d9983f2714c9b8cd.js"></script>
                                <p class="ejemplo">Captura en ejecución: </p>
                                <img src="./img/3/3.3.2.jpg" alt="">


                </div>
                <div class="unidad" id="registros">
                    <h2>Módulo 4: Registros.</h2>
                        <h3>4.1. Definición.</h3>
                        <p>En el lenguaje C, los registros son una colección de una o más variables, de tipos posiblemente diferentes, las cuales son agrupadas bajo un solo nombre para manejo conveniente. Los registros, en el lenguaje C son también conocidos como estructuras. Los registros ayudan a organizar datos complicados, en particular dentro de programas grandes, debido a que permiten que a un grupo de variables relacionadas se les trate como una unidad en lugar de como entidades separadas. Los registros pueden ser copiados, se puede obtener su dirección en memoria, se puede acceder a los valores de sus miembros, y por ende, pueden ser pasados como parámetros o también ser regresados por una función. Los registros fueron diseñados para que los programadores pudieran crear su “propio tipo de dato”, el cual se ajusta a necesidades, en lenguaje C, los registros es lo que mas se acerca a una tabla en una base de datos.</p>
                        <p>El modificador typedef nos permite definir a una estructura como un tipo de dato nuevo para el lenguaje C, se necesita especificar que nombre se le asignara al nuevo tipo de dato.</p>
                        <br>
                        <p><b>Tipos de registro.</b></p>
                        <br>
                        <p><b>Registros simples: </b>Este tipo de registro solo contiene información de una sola entidad.</p>
                        <br>
                        <pre>typedef struct {<br>    char nombre[50];<br>    char sexo[20];<br>    char rfc[13];<br>    char domicilio[100];<br>} Empleado;</pre>
                        <br>
                        <p><b>Registros anidados: </b>Este tipo de registro permite contener datos de diferentes entidades que tengan una relación entre si.</p>
                        <br>
                        <pre>typedef struct {<br>    char fecha[50];<br>    int tieneSeguroMedico;<br>    struct Empleado{<br>        char nombre[50];<br>        char sexo[20];<br>        char rfc[13];<br>        char domicilio[100];<br>    } paciente;<br>    char enfermedadCronica[50];<br>} RegistroMedico;</pre>
                        <br>
                        <p><b>Arreglos de registros: </b>Este tipo de registro funciona al igual que un registro de datos primitivos. Al igual que un arreglo normal este nos permite juntar varios datos del mismo tipo en el mismo identificador y accediendo a estos a través de un índice, solo que en este caso es un tipo de dato que nosotros mismos definimos.</p>
                        <br>
                        <pre>typedef struct {<br>    char fecha[50];<br>    int quincena;<br>    struct Empleado{<br>        char nombre[50];<br>        int sexo;<br>        char rfc[13];<br>        char domicilio[100];<br>    } empleados[10];<br>    int bonos;<br>    int fondoDeAhorro;<br>} Nomina;</pre>
                        <h3>4.2. Operaciones con registros.</h3>
                            <h4 class="sub">4.2.1. Asignación a los datos de un registro.</h4>
                            <p>Existen dos maneras basicas de asignar datos a los registros, en una se trabaja con registros que son declarados globalmente o localmente pero fueron declarados en la misma función que se esta modificando. Y en la segunda manera se trabaja con direcciones de memoria para transferir registros entre funciones.</p>
                            <br>
                            <p><b>Asignación con operador miembro de la estructura: </b>El operador miembro de la estructura se representa en C como un punto (.), este operador se utiliza para referenciar en especifico a un campo de la estructura. Para utilizar este método se pone el nombre del alias de la estructura seguido de un punto y el campo en el que se quieren guardar los datos.</p>
                                <p class="ejemplo">Ejemplo:</p>
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/23aff68e9b201d614a096976fe68a354.js"></script>
                                
                                <p><b>Asignación utilizando punteros: </b>Para utilizar los punteros de registros es necesario que el registro sea declarado en modo puntero o en su defecto que se pase la dirección de memoria de la estructura a otra función.</p>
                                <p>Para la asignación de datos de un registro utilizando punteros se pueden utilizar dos métodos, el primero es con el signo de puntero (*) en conjunto con el operador miembro de la estructura (.), se indica que es un puntero, se pone el alias y estos dos se encierran en parentesis, posteriormente se pone el operador miembro de la estructura y el campo al cual se quiere acceder.</p>
                                <p>O existe el operador flecha (->), el cual fue hecho por los creadores del lenguaje C para abreviar el método anterior, sobre todo para que el código tuviera más legibilidad. En los siguientes ejemplos solo emplearé el operador flecha ya que tiene una legibilidad mayor.</p>
                                <p class="ejemplo">Ejemplo:</p>
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/8b2c19f3666abec09b1bee4d8e4dffa1.js"></script>

                            <h4 class="sub">4.2.2. Salida de datos de un registro.</h4>
                            <p>Al igual que la asignación, existen dos métodos basicos para asignar datos a un registro, con el operador miembro de la estructura (.) y con el operador flecha (->).</p>
                            <br>
                            <p><b>Salida de datos con el operador miembro de la función:</b></p>
                                <p class="ejemplo" style="margin-top: 0 !important;">Ejemplo.</p>
                                <p class="ejemplo">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/000fd59ce57967cef6b757689aca619f.js"></script>
                            
                            <p>Al igual que la asignación, existen dos métodos basicos para asignar datos a un registro, con el operador miembro de la estructura (.) y con el operador flecha (->).</p>
                            <br>
                            <p><b>Salida de datos utilizando punteros:</b></p>
                                <p class="ejemplo">Ejemplo.</p>
                                <p class="ejemplo" style="margin-top: 0 !important;">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/d0296b4752eb376060bcf10321860471.js"></script>

                        <h3>4.3. Arreglos con elementos de tipo registro.</h3>
                            <h4 class="sub">4.3.1. Definición</h4>
                            <p>Los arreglos con elementos de tipo registro son una colección de varias entidades relacionadas que tienen algo en común y las cuales, cada una guarda varios datos que pueden ser de diferentes tipos, o tambien pueden guardar otros registros. Estos son agrupados en un solo identificador y se accede a ellos gracias a un índice.</p>
                            <p>También se les conoce como una expansión lateral de las estructuras simples o estructuras anidadas, ya que se pasa de guardar un solo valor en cada campo a guardar varios datos con la misma estructura sin declarar varios alias.</p>
                            <h4 class="sub">4.3.2. Operaciones con arreglos de registros</h4>
                            <p>Este tipo de registro está sujeto a las operaciones fundamentales de lso registros, copiarla, asignarla, tomar su dirección y tener acceso a los miembros de sus elementos. Sin embargo, los miembros de sus elementos si pueden utilizar todas las operaciones que vienen con su tipo de dato, en caso de enteros o flotantes, operaciones numéricas, en caso de cadenas de carácteres, funciones de la libreria String.h.</p>
                            <p>Aqui se debe de mencionar algo importante con respecto al uso de punteros con este tipo de registros, ya que puede resultar algo complicado. Para poder lograr pasar o referenciar el arreglo de registros que contiene una función es necesario crear un puntero del mismo tipo que la estructura, sin embargo este será un puntero simple, sin dimensión, a diferencia del arreglo. Este apuntará al principio del arreglo de registros y para pasar al siguiente elemento del arreglo se debe de incrementar en 1 el puntero.</p>
                            <h4>4.3.2.1. Entrada de datos de los elementos de un arreglo de registros.</h4>
                            <p><b>Por inicialización: </b>La inicialización se puede realizar únicamente cuando se declara el alias, de otra manera no se podrán inicializar todos los valores de una sola vez.</p>
                                <p class="ejemplo">Ejemplo.</p>
                                <p class="ejemplo" style="margin-top: 0 !important;">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/f2046451c6c2a40a97a41c2125e84b40.js"></script>
                            <p><b>Asignación por el operador miembro de la estructura: </b>Se utiliza de igual manera que en los otros tipos de estructura, solo que agregando el índice al alias para especificar cual elemento del arreglo se quiere acceder. Recordemos que el operador miembro de la estructura es representado con un punto (.) y se utiliza para referenciar a un campo especifico de la estructura y no a toda la estructura.</p>
                                <p class="ejemplo">Ejemplo.</p>
                                <p class="ejemplo" style="margin-top: 0 !important;">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/44e5d5c2dd22d6aa087cf028a44b0569.js"></script>
                            <p><b>Asignación utilizando punteros: </b>Se utilizan de igual manera que en los otros tipos de estructura, solo que recordemos la advertencia anterior, los punteros para los arreglos de registros son un puntero que apunta al principio del arreglo y posteriormente se tiene que incrementar su valor para que itere por el arreglo.</p>
                                <p class="ejemplo">Ejemplo.</p>
                                <p class="ejemplo" style="margin-top: 0 !important;">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/695511470d7eb56c2434fc04ea51c570.js"></script>

                            <h4>4.3.2.2. Salida de datos de un arreglo de registros.</h4>
                            <p>Los métodos de salida de datos de un arreglo de registros son los mismos métodos que se utilizan para entrada de datos, solo se utilizan otras funciones para hacer esto, en lugar de scanf se utiliza printf por ejemplo.</p>
                            <br>
                            <p><b>Salida por el operador miembro de la estructura: </b>Se utiliza de igual manera que en la entrada de datos, se especifica el alias seguido del índice al que se quiere acceder, seguido del operador (.) y el campo que se quiere imprimir.</p>
                                <p class="ejemplo">Ejemplo.</p>
                                <p class="ejemplo" style="margin-top: 0 !important;">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/66a303f023753cd4deced2bcdb6a7394.js"></script>

                            <p><b>Salida utilizando punteros: </b>Se utilizan los mismos métodos que en la entrada de datos. Recordemos que los punteros de los arreglos de registros apuntan al primer elemento del arreglo, por lo que si se quiere utilizar para todos los elementos se tiene que incrementar el valor del puntero para que apunte hacia el siguiente elemento.</p>
                                <p class="ejemplo">Ejemplo.</p>
                                <p class="ejemplo" style="margin-top: 0 !important;">Código en C:</p>
                                <script src="https://gist.github.com/isaac-bh/1f548a551a2c137cc4b4dcfd6166f43e.js"></script>
                </div>
            </div>
        </main>
        <aside>
            <div class="lateral">
                <a href="">Módulo 1: Programación estructurada</a>
            </div>
        </aside>
    </div>

</body>
</html>